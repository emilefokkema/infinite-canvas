// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`an infinite canvas context > draws a line to infinity > and then draws a line back from infinity to a point and then strokes > should draw the right line back to the point 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineTo(201.41421356,60)",
  "context.lineTo(30,60)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line back and fills > should draw a path that ends coming from the correct direction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(60,200)",
  "context.lineTo(60,60)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with finite height but located at negative infinity horizontally > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with finite height but located at positive infinity horizontally > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with finite width but located at negative infinity vertically > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with finite width but located at positive infinity vertically > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with finite width, infinite height and no top > should clear a rect extending to the top and bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,0,50,200)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with infinite height but located infinitely far down > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with infinite width, infinite height and no left > should clear a rect extending to the left and right and bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,50,200,150)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with infinite width, infinite height and no top > should clear a rect extending to the top and bottom and right of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,0,150,200)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with infinite width, negative infinite height and no bottom > should clear a rect extending to the top and bottom and right of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,200,150,-200)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with negative infinite height > should clear a rectangle extending to the top of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,50,50,-50)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with negative infinite width > should clear a rectangle extending to the left side of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,50,-50,50)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with negative infinite width, infinite height and no right > should clear a rect extending to the left and right and bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(200,50,-200,150)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with positive infinite height > should clear a rectangle extending to the bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,50,50,150)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with positive infinite width > should clear a rectangle extending to the right side of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,50,150,50)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears a rect with positive infinite width and positive infinite height > should clear a rect extending to the right and to the bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(50,50,150,150)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears the entire plane > should clear everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > and then clears the entire plane differently > should clear everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then draws a line to a third point at infinity (not in the same half plane) and then fills > should draw the correct path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then fills > should create a path that covers the correct section of the view box 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then fills the path and clears a rect not overlapping the drawn area > should not add a clearRect 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to another point at infinity > and then fills the path and clears a rect overlapping the drawn area > should add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(200,30)",
  "context.lineTo(200,200)",
  "context.lineTo(30,200)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(40,40,60,60)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then draws a line to the opposite point at infinity and strokes > should still have drawn only a ray 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the path > should draw a line to the right border of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears a rect not overlapping the ray > should not have added a clearRect 1`] = `[]`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears a rect overlapping the entire ray > should forget about the drawn path and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears a rect overlapping the ray > should have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,0,60,60)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears a rect overlapping the ray > should have added a clearRect 2`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(300,0,60,60)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears an infinite rectangle partially overlapping the ray > and then the viewbox transformation scales > should clear a rectangle extending to the edge of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(60,60)",
  "context.lineTo(202.82842712,60)",
  "context.lineWidth = 2",
  "context.stroke()",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.clearRect(40,20,60,20)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears an infinite rectangle partially overlapping the ray > and then the viewbox transformation translates > should clear a rectangle extending to the edge of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(20,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.save()",
  "context.transform(1,0,0,1,-10,0)",
  "context.clearRect(40,20,170,20)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > draws a line to infinity > and then strokes the ray and clears an infinite rectangle partially overlapping the ray > should clear a rectangle extending to the edge of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(201.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(40,20,160,20)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > and then reduces the path's area, clips again and fills a rect > and then reduces the path's area again and fills it > should have recreated the path and filled it 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.lineTo(50,90)",
  "context.fillStyle = \\"#ff0\\"",
  "context.fill()",
]
`;

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > and then reduces the path's area, clips again and fills a rect > should have added a filled rectangle after the clip 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > should have added an instruction to clip 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = \\"#0f0\\"",
  "context.fill()",
]
`;

exports[`an infinite canvas context > saves, changes state, begins drawing a path > and then fills a rect, restores to the previous state and then fills the path > should end up with an equal number of saves and restores 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.save()",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,30)",
  "context.lineTo(10,30)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > saves, changes state, begins drawing a path > and then restores to the previous state, fills a rect and then fills the path > should end up with an equal number of saves and restores 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,30)",
  "context.lineTo(10,30)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.save()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that adds a drawing that depends on the transformation > and then draws using a non-identity transformation > should have set the transformed version of the state 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineDashOffset = 2",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that alters its state and draws a rectangle > and then clears a rectangle containing the drawing > should have cleared a rectangle and nothing else 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that alters its state and draws a rectangle > should have called the context methods 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(2,1)",
  "context.lineTo(2,2)",
  "context.lineTo(1,2)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins a path > and then adds a rect that has no area > and then adds a line to a finite point and strokes it > should have drawn a ray from the position of the rect without area 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(-1.41421356,100)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line back to the first point at infinity > and then strokes > should add a moveTo 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineTo(201.41421356,200)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line to the point at infinity opposite the starting point > and then adds a line back to the original point at infinity > and then fills > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line to the point at infinity opposite the starting point > and then adds a new subpath that is closable and closes it > and then strokes > should close the second subpath but not the first 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineTo(-1.41421356,200)",
  "context.moveTo(150,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,50)",
  "context.closePath()",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line to the point at infinity opposite the starting point > and then closes the path and strokes > should have stroked but not closed the path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineTo(-1.41421356,200)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line to the point at infinity opposite the starting point > and then fills > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then adds a line to the point at infinity opposite the starting point > and then transforms and adds a line back to the original point at infinity > and then fills > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then strokes > and then adds a line to another finite point > and then strokes > should have created two paths 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,200)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(201.41421356,300)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineWidth = 1",
  "context.lineTo(100,300)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different finite point > and then strokes > should begin with a moveTo and a lineTo 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,200)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(100,200)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different point at infinity > and then adds a line to a finite point > and then strokes > should have drawn the correct path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,150)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,201.41421356)",
  "context.lineTo(50,201.41421356)",
  "context.lineTo(50,150)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different point at infinity > and then adds a line to yet a different point at infinity > and then strokes > should draw the correct path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(-26.41421356,23.58578644)",
  "context.lineTo(-1.41421356,-1.41421356)",
  "context.lineTo(201.41421356,-1.41421356)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,201.41421356)",
  "context.lineTo(-1.41421356,201.41421356)",
  "context.lineTo(-26.41421356,23.58578644)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different point at infinity > and then strokes > should begin a path with a move to and then draw a line around a corner of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,201.41421356)",
  "context.lineTo(201.41421356,201.41421356)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,201.41421356)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to a different point at infinity > and then strokes the path using a line dash > should draw a path whose length is a multiple of the line dash period 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,201.41421356)",
  "context.lineTo(201.41421356,201.41421356)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(202.5,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(203.20710678,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,201.41421356)",
  "context.lineTo(50,203.20710678)",
  "context.lineTo(50,201.41421356)",
  "context.setLineDash([3,2])",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then adds a line to the opposite point at infinity > and then strokes > should have added a moveTo 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(-1.41421356,100)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then strokes > and then lines to a different finite point > and then strokes > should have created two paths 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(201.41421356,200)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineWidth = 1",
  "context.lineTo(100,200)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then strokes > should have added a moveTo 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to a finite point > and then strokes the line using a line dash > should draw a line whose length is a multiple of the line dash period 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(203.20710678,100)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.setLineDash([3,2])",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to another point at infinity > and then adds a line to a finite point > and then fills > should have drawn the right path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(200,100)",
  "context.lineTo(200,200)",
  "context.lineTo(100,200)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to another point at infinity > and then adds a line to a third point at infinity that is not in the same half plane > and then fills > should draw a path around the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.rect(0,0,200,200)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins a path and moves to infinity > and then adds a line to another point at infinity > and then fills > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that begins path > and then builds it and fills it > and then clears a smaller area than the one that was closed and adds another instruction > and then clears an area containing all previous instructions > and then draws something else > should have cleared a rectangle once more 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins path > and then builds it and fills it > and then clears a smaller area than the one that was closed and adds another instruction > and then clears an area containing all previous instructions > should have cleared a rectangle once 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that begins path > and then builds it and fills it > and then clears a smaller area than the one that was closed and adds another instruction > should still have executed the instructions in the completed area and should have added a clear rect instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(3,0)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,0,2,2)",
  "context.restore()",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that begins path > and then builds it and fills it > and then clears an area that is outside the drawn area > should not have done anything 1`] = `[]`;

exports[`an infinite canvas context > that begins path > and then builds it and fills it > should have executed the new instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(3,0)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins path > and then changes state and fills a rect > and then adds a rect to the path and fills it > should do that using the same changed state 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.fillStyle = \\"#000\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.fillStyle = \\"#f00\\"",
  "context.moveTo(0,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,4)",
  "context.lineTo(0,4)",
  "context.lineTo(0,2)",
  "context.closePath()",
  "context.moveTo(0,2)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins path > and then changes state and fills a rect > should have remembered the state change 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that begins path > and then changes state, begins a new path and fills it > should have remembered the state change 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips and fills with shadow and then clears a rect > should not have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that clips and then draws an image > and then clears an area covering the clipped area but not the image > should forget about the image and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > and then fills a rect inside the clipped area > and then clears the entire area > should have cleared everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > and then fills a rect inside the clipped area > should have added a fillRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(50,30)",
  "context.lineTo(50,50)",
  "context.lineTo(30,50)",
  "context.lineTo(30,30)",
  "context.closePath()",
  "context.moveTo(30,30)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(35,35)",
  "context.lineTo(45,35)",
  "context.lineTo(45,45)",
  "context.lineTo(35,45)",
  "context.lineTo(35,35)",
  "context.closePath()",
  "context.moveTo(35,35)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > should not have added a fillRect 1`] = `[]`;

exports[`an infinite canvas context > that clips and then puts image data > and then clears an area covering the clipped area but not the image > should not forget about the image and add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.imageSmoothingEnabled = false",
  "context.translate(0,0)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.fillRect(0,0,200,200)",
  "context.restore()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(9,9,12,12)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > and then removes the second filled rectangle by clearing a rect > and then removes the first filled rectangle by clearing a rect > should still contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > and then removes the second filled rectangle by clearing a rect > should still contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.lineTo(0,5)",
  "context.closePath()",
  "context.moveTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > should contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.lineTo(0,5)",
  "context.closePath()",
  "context.moveTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,5)",
  "context.lineTo(9,5)",
  "context.lineTo(9,7)",
  "context.lineTo(7,7)",
  "context.lineTo(7,5)",
  "context.closePath()",
  "context.moveTo(7,5)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.lineTo(5,5)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then fills using the linear gradient > and then clears the drawing > and then fills the path again > should create a linear gradient again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.fillStyle = \\"[linear-gradient-1]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then fills using the linear gradient > and then clears the drawing > should no longer create a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then fills using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.fillStyle = \\"[linear-gradient-0]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then strokes using the linear gradient > and then clears the drawing > and then strokes the path again > should create a linear gradient again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.strokeStyle = \\"[linear-gradient-1]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then strokes using the linear gradient > and then clears the drawing > should no longer create a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then creates a path > and then strokes using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.strokeStyle = \\"[linear-gradient-0]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > and then fills again using the same linear gradient > and then clears both drawings with the linear gradient > should not have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > and then fills again using the same linear gradient > and then clears one drawing with the linear gradient > and then clears the other drawing with the linear gradient > and then draws again using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-3]",
  "context.fillStyle = \\"[linear-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > and then fills again using the same linear gradient > and then clears one drawing with the linear gradient > and then clears the other drawing with the linear gradient > should not have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > and then fills again using the same linear gradient > and then clears one drawing with the linear gradient > should still have created only one linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-2]",
  "context.fillStyle = \\"[linear-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > and then fills again using the same linear gradient > should still have created only one linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.fillStyle = \\"[linear-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then fills using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.fillStyle = \\"[linear-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > and then strokes again using the same linear gradient > and then clears both drawings with the linear gradient > should not have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > and then strokes again using the same linear gradient > and then clears one drawing with the linear gradient > and then clears the other drawing with the linear gradient > and then draws again using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-3]",
  "context.strokeStyle = \\"[linear-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > and then strokes again using the same linear gradient > and then clears one drawing with the linear gradient > and then clears the other drawing with the linear gradient > should not have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > and then strokes again using the same linear gradient > and then clears one drawing with the linear gradient > should still have created only one linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-2]",
  "context.strokeStyle = \\"[linear-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > and then strokes again using the same linear gradient > should still have created only one linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-1]",
  "context.strokeStyle = \\"[linear-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > and then strokes using the linear gradient > should have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createLinearGradient(10,0,10,30)",
  "=> [linear-gradient-0]",
  "context.strokeStyle = \\"[linear-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > should not have created a linear gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a linear gradient > and then draws without using the linear gradient > should not have created a linear gradient 2`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a pattern > and then uses it to fill a rect > should wrap the fill command in a transform 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then fills using the radial gradient > and then clears the drawing > and then fills the path again > should create a radial gradient again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.fillStyle = \\"[radial-gradient-1]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then fills using the radial gradient > and then clears the drawing > should no longer create a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then fills using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.fillStyle = \\"[radial-gradient-0]\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then strokes using the radial gradient > and then clears the drawing > and then strokes the path again > should create a radial gradient again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.strokeStyle = \\"[radial-gradient-1]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then strokes using the radial gradient > and then clears the drawing > should no longer create a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then creates a path > and then strokes using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineTo(2,1)",
  "context.lineWidth = 1",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.strokeStyle = \\"[radial-gradient-0]\\"",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > and then fills again using the same radial gradient > and then clears both drawings with the radial gradient > should not have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > and then fills again using the same radial gradient > and then clears one drawing with the radial gradient > and then clears the other drawing with the radial gradient > and then draws again using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-3]",
  "context.fillStyle = \\"[radial-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > and then fills again using the same radial gradient > and then clears one drawing with the radial gradient > and then clears the other drawing with the radial gradient > should not have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > and then fills again using the same radial gradient > and then clears one drawing with the radial gradient > should still have created only one radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-2]",
  "context.fillStyle = \\"[radial-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > and then fills again using the same radial gradient > should still have created only one radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.fillStyle = \\"[radial-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then fills using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.fillStyle = \\"[radial-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > and then strokes again using the same radial gradient > and then clears both drawings with the radial gradient > should not have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > and then strokes again using the same radial gradient > and then clears one drawing with the radial gradient > and then clears the other drawing with the radial gradient > and then draws again using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-3]",
  "context.strokeStyle = \\"[radial-gradient-3]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > and then strokes again using the same radial gradient > and then clears one drawing with the radial gradient > and then clears the other drawing with the radial gradient > should not have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > and then strokes again using the same radial gradient > and then clears one drawing with the radial gradient > should still have created only one radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-2]",
  "context.strokeStyle = \\"[radial-gradient-2]\\"",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > and then strokes again using the same radial gradient > should still have created only one radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-1]",
  "context.strokeStyle = \\"[radial-gradient-1]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(60,0)",
  "context.lineTo(60,10)",
  "context.lineTo(50,10)",
  "context.lineTo(50,0)",
  "context.closePath()",
  "context.moveTo(50,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > and then strokes using the radial gradient > should have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
  "context.createRadialGradient(0,0,1,5,5,5)",
  "=> [radial-gradient-0]",
  "context.strokeStyle = \\"[radial-gradient-0]\\"",
  "context.beginPath()",
  "context.moveTo(30,0)",
  "context.lineTo(40,0)",
  "context.lineTo(40,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,0)",
  "context.closePath()",
  "context.moveTo(30,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > should not have created a radial gradient 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a radial gradient > and then draws without using the radial gradient > should not have created a radial gradient 2`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a rect that extends to infinity and strokes it > and then changes the line width and strokes the rectangle again > should have taken a different line width into account this time 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(201.41421356,50)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(205.65685425,50)",
  "context.lineTo(205.65685425,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.lineWidth = 4",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a rect that extends to infinity and strokes it > should have taken the current line width into account 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(201.41421356,50)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates a rectangular path, fills another rectangle and then fills the created path > should have filled both rectangles 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(100,50)",
  "context.lineTo(100,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that creates a rectangular path, strokes another rectangle and then strokes the created path > should have stroked both rectangles 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.strokeStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(100,50)",
  "context.lineTo(100,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that creates image data > and then puts it on the context > and then the bitmap is ready > and then drawing is executed > and then part of the drawing is cleared > should have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.imageSmoothingEnabled = false",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.fillRect(0,0,10,10)",
  "context.restore()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(5,5,10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that creates image data > and then puts it on the context > and then the bitmap is ready > and then drawing is executed > and then the entire drawing is cleared > should have forgotten everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that creates image data > and then puts it on the context > and then the bitmap is ready > and then drawing is executed > should have filled a rect using a pattern created from the bitmap 1`] = `
[
  "context.createPattern({\\"height\\":10,\\"width\\":10},\\"no-repeat\\")",
  "=> [pattern-0]",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.imageSmoothingEnabled = false",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.fillRect(0,0,10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that creates image data > and then puts part of it on the context > and then the bitmap is ready > and then drawing is executed > should have filled a rect using a pattern created from the bitmap 1`] = `
[
  "context.createPattern({\\"height\\":8,\\"width\\":8},\\"no-repeat\\")",
  "=> [pattern-0]",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.imageSmoothingEnabled = false",
  "context.translate(10,10)",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.fillRect(0,0,8,8)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that does this > should have done this 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,10,10)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(25,0)",
  "context.lineTo(25,25)",
  "context.lineTo(0,25)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.setTransform(1,0,0,1,60,10)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(25,0)",
  "context.lineTo(25,25)",
  "context.lineTo(0,25)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that draws a bezier curve > and then clear a rect that fully covers the bezier curve > should no longer draw a bezier curve 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that draws a bezier curve > and then clears a rect that does not overlap the bezier curve > should not do anything else 1`] = `[]`;

exports[`an infinite canvas context > that draws a bezier curve > and then clears a rect that partially covers the bezier curve > should add a clearRect command 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.bezierCurveTo(100,50,0,50,50,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,30,100,100)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that draws a bezier curve > should draw a bezier curve 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.setTransform(1,0,0,1,20,20)",
  "context.moveTo(0,0)",
  "context.bezierCurveTo(20,0,20,20,40,20)",
  "context.lineTo(40,40)",
  "context.lineTo(0,40)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a bezier curve > should draw a bezier curve 2`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.bezierCurveTo(100,50,0,50,50,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a line > and then draws a line to infinity in a different direction and fills the path > should have filled the right shape 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,20)",
  "context.lineTo(200,20)",
  "context.lineTo(200,10)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a line > and then draws a line to infinity in the opposite direction and fills the path > should not have drawn more lines than necessary 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,20)",
  "context.lineTo(10,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a line > and then draws a line to infinity in the same direction and fills the path > should not have drawn more lines than necessary 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,20)",
  "context.lineTo(10,200)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a line without calling 'moveTo' > should draw a line 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(20,10)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that draws a path at infinity with four points and fills it > should have filled the entire plane 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.rect(0,0,200,200)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a path, fills it and then adds to the path > and then strokes the path > should have executed the last path modification only once 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(30,100)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(30,100)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.lineTo(100,30)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that draws a path, transforms and then strokes > should have kept that order 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(110,10)",
  "context.lineTo(110,110)",
  "context.lineTo(10,110)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.lineWidth = 6",
  "context.setTransform(0.2,0,0,1,0,0)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that draws a quadratic curve > and then clears a rect that covers the quadratic curve > should no longer draw a quadratic curve 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that draws a quadratic curve > and then clears a rect that does not cover the quadratic curve > should still draw a quadratic curve 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.quadraticCurveTo(60,60,110,10)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(5,5,110,25)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that draws a quadratic curve > should draw a quadratic curve 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(40,20)",
  "context.setTransform(1,0,0,1,40,20)",
  "context.quadraticCurveTo(20,0,20,20)",
  "context.lineTo(20,60)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a quadratic curve > should draw a quadratic curve 2`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.quadraticCurveTo(60,60,110,10)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a square by translating > and then fully clears the drawn square > should not have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that draws a square by translating > and then partly clears the drawn square > should have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.setTransform(1,0,0,1,1,0)",
  "context.moveTo(0,0)",
  "context.setTransform(1,0,0,1,1,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,0)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0.5,0,2,2)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that draws a square by translating > should have called transform before each move 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.setTransform(1,0,0,1,1,0)",
  "context.moveTo(0,0)",
  "context.setTransform(1,0,0,1,1,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,1)",
  "context.lineTo(0,0)",
  "context.setTransform(1,0,0,1,0,0)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws a triangular path and then clears a rect outside the triangle > should not have added a clearRect 1`] = `[]`;

exports[`an infinite canvas context > that draws an arc > should draw an arc 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(60,30)",
  "context.save()",
  "context.transform(1,0,0,1,30,30)",
  "context.arc(0,0,30,0,6.28318531,)",
  "context.restore()",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that draws an ellipse > should draw an ellipse 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(150,50)",
  "context.ellipse(50,50,100,40,0,0,3.14159265,)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect and adds a clearRect that partially covers it > and then adds a clearRect with negative width and height that covers the previous clearRect entirely > should end up with only one clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(100,50)",
  "context.lineTo(100,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(75,75,-50,-50)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that fills a rect with finite width and negative infinite height > should fill a rect that extends to outside of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(50,20)",
  "context.lineTo(50,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.closePath()",
  "context.moveTo(20,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect with finite width and positive infinite height > should fill a rect that extends to outside of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(50,20)",
  "context.lineTo(50,200)",
  "context.lineTo(20,200)",
  "context.lineTo(20,200)",
  "context.lineTo(20,20)",
  "context.closePath()",
  "context.moveTo(20,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect with negative infinite width and a finite height > should fill a rect that extends to outside of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,50)",
  "context.lineTo(20,50)",
  "context.lineTo(20,20)",
  "context.closePath()",
  "context.moveTo(20,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect with only a right edge > should fill a rect that fills the left half of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(100,0)",
  "context.lineTo(0,0)",
  "context.lineTo(0,200)",
  "context.lineTo(100,200)",
  "context.lineTo(100,0)",
  "context.lineTo(100,0)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect with only a top edge > should fill a rect that fills the bottom half of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,100)",
  "context.lineTo(0,100)",
  "context.lineTo(200,100)",
  "context.lineTo(200,200)",
  "context.lineTo(0,200)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect with positive infinite width and a finite height > should fill a rect that extends to outside of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(200,20)",
  "context.lineTo(200,50)",
  "context.lineTo(20,50)",
  "context.lineTo(20,20)",
  "context.closePath()",
  "context.moveTo(20,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect without area > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that fills a rect without bottom edge with negative infinite height and a finite width > should fill a rect that extends to the top and bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,200)",
  "context.lineTo(50,0)",
  "context.lineTo(50,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,200)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect without left edge with positive infinite width and a finite height > should fill a rect that extends to the left and right of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,20)",
  "context.lineTo(0,20)",
  "context.lineTo(200,20)",
  "context.lineTo(200,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,50)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect without right edge with negative infinite width and a finite height > should fill a rect that extends to the left and right of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(200,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,50)",
  "context.lineTo(0,50)",
  "context.lineTo(200,50)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect without top edge with positive infinite height and a finite width > should fill a rect that extends to the top and bottom of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(50,0)",
  "context.lineTo(50,200)",
  "context.lineTo(20,200)",
  "context.lineTo(20,0)",
  "context.lineTo(20,0)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rect, begins a new path, translates and then clears a rect > should add a clearRect with the right arguments 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.setTransform(1,0,0,1,1,1)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(1,1,1,1)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that fills a rectangle, clears part of it and then clears a bigger part of it > should end up with only one clear rect instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(1,1,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that fills a rectangle, creates a path inside it, clears a rectangle inside the first rectangle and then fills the created path > should have executed everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,0,75,75)",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(50,0)",
  "context.lineTo(50,50)",
  "context.lineTo(0,50)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that fills a rectangle, fills a smaller rectangle inside it and clears a rectangle containing the small one but not the big one > should forget all about the second rectangle 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(5,0)",
  "context.lineTo(5,5)",
  "context.lineTo(0,5)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(1,1,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that fills the entire plane > should fill the entire viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.save()",
  "context.setTransform(1,0,0,1,0,0)",
  "context.rect(0,0,200,200)",
  "context.restore()",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that has this screen transformation > and that uses canvas units > and that draws a square using a drop-shadow filter > and that transforms in this way > should set the filter correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,150)",
  "context.setTransform(2,0,0,0.5,0,-25)",
  "context.filter = \\"drop-shadow(120px -30px)\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,200)",
  "context.lineTo(0,120)",
  "context.lineTo(80,120)",
  "context.lineTo(80,200)",
  "context.lineTo(0,200)",
  "context.closePath()",
  "context.moveTo(0,200)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that has this screen transformation > and that uses canvas units > and that draws a square using a shadow > and that transforms in this way > should set the shadow offset correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,150)",
  "context.setTransform(2,0,0,0.5,0,-25)",
  "context.lineWidth = 1",
  "context.shadowOffsetX = 120",
  "context.shadowOffsetY = -30",
  "context.shadowColor = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,200)",
  "context.lineTo(0,120)",
  "context.lineTo(80,120)",
  "context.lineTo(80,200)",
  "context.lineTo(0,200)",
  "context.closePath()",
  "context.moveTo(0,200)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that has this screen transformation > and that uses css units > and that draws a square using a drop-shadow filter > and that transforms in this way > should set the filter correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,150)",
  "context.setTransform(0.75,0,0,0.375,0,0)",
  "context.filter = \\"drop-shadow(45px -22.5px)\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,200)",
  "context.lineTo(0,120)",
  "context.lineTo(80,120)",
  "context.lineTo(80,200)",
  "context.lineTo(0,200)",
  "context.closePath()",
  "context.moveTo(0,200)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that has this screen transformation > and that uses css units > and that draws a square using a shadow > and that transforms in this way > should set the shadow offset correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,150)",
  "context.setTransform(0.75,0,0,0.375,0,0)",
  "context.lineWidth = 1",
  "context.shadowOffsetX = 45",
  "context.shadowOffsetY = -22.5",
  "context.shadowColor = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,200)",
  "context.lineTo(0,120)",
  "context.lineTo(80,120)",
  "context.lineTo(80,200)",
  "context.lineTo(0,200)",
  "context.closePath()",
  "context.moveTo(0,200)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that is translated > and then adds a rectangular path and fills it > and then clears a rectangle partly covering the place where the rectangle was drawn > should have added an instruction to clear a rect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0.5,0,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that is translated > and then draws a rectangle > and then clears a rectangle partly covering the place where the rectangle was drawn > should have added an instruction to clear a rect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0.5,0,3,3)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that is translated > and then draws a rectangle > should have called setTransform on the context 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.setTransform(1,0,0,1,2,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that is translated > and then the viewbox is transformed and it draws a rectangle > should have called setTransform on the context with the right transformation 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 2",
  "context.setTransform(1,0,0,1,4,0)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that makes a path consisting of two subpaths > and the fills it using a fill rule > should take the fill rule into account 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(110,10)",
  "context.lineTo(110,110)",
  "context.lineTo(10,110)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.moveTo(30,30)",
  "context.lineTo(60,30)",
  "context.lineTo(60,60)",
  "context.lineTo(30,60)",
  "context.lineTo(30,30)",
  "context.closePath()",
  "context.moveTo(30,30)",
  "context.lineWidth = 1",
  "context.fill(\\"evenodd\\")",
]
`;

exports[`an infinite canvas context > that makes a path extending to infinity and fills it > and then strokes it > should take the line width into account for the stroked path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,100)",
  "context.lineTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(-1.41421356,100)",
  "context.lineTo(-1.41421356,-1.41421356)",
  "context.lineTo(100,-1.41421356)",
  "context.lineTo(100,-1.41421356)",
  "context.lineTo(100,100)",
  "context.lineTo(-1.41421356,100)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that makes a path with zero area and strokes it > and then clears an area overlapping but not covering the path > should have added a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(30,30)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(25,25,30,30)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that makes a path, fills a rect, fills the path, begins a new path and then clears a rect containing the first drawn path > should forget the first drawn path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(3,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,4)",
  "context.lineTo(3,4)",
  "context.lineTo(3,3)",
  "context.closePath()",
  "context.moveTo(3,3)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that makes a path, fills it and then fills an overlapping rect > and then fills the path again > should not have forgotten the previous path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that makes a path, fills it and then fills an overlapping rect > should draw the two rectangles in the right order 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineTo(0,2)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that makes a path, fills it, clears it completely with a clearRect, expands it and strokes it > should no longer fill the path 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(1,2)",
  "context.lineTo(2,2)",
  "context.lineWidth = 1",
  "context.lineTo(2,1)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that makes a path, saves state, clips, fills a rect and then strokes the path > should set the clipped path before stroking 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that makes a rect, strokes it and then strokes text > should set the line width twice 1`] = `
[
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 2",
  "context.stroke()",
  "context.lineWidth = 1",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.strokeText(\\"text\\",10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves and fills a rect > should call restore() after drawing 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(30,10)",
  "context.lineTo(30,30)",
  "context.lineTo(10,30)",
  "context.lineTo(10,10)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, begins a path, restores state and fills a rect > should end up with an equal number of saves and restores 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > and then makes a new rectangular path partly overlapping the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > and then once more fills a rect partly overlapping the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > and then clears a rect containing the first overlap > should still contain one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.lineTo(0,4)",
  "context.closePath()",
  "context.moveTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > and then clears a rect containing the second overlap > should still contain one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > should still contain only one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.lineTo(0,4)",
  "context.closePath()",
  "context.moveTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and begins a path outside the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and begins a path outside the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and fills a rect outside the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and fills a rect outside the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > should contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > and then fills a rect partly overlapping the clipped area > should contain the clipping instruction again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > and then once again fills the path > should contain the clipping instruction again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and begins a path outside the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and begins a path outside the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and fills a rect outside the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and fills a rect outside the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,0)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > should contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves, begins a path, begins another path, fills it, restores and then fills a rect > should end up with an equal number of saves and restores 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(2,0)",
  "context.lineTo(2,2)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves, creates a path, fills two rects, restores and strokes > should have the same number of saves and restores 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.setTransform(1,0,0,1,1,1)",
  "context.save()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(1,0)",
  "context.lineTo(1,1)",
  "context.lineTo(0,1)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that sets a line width, makes a rect, strokes it and then strokes text > should set the line width twice 1`] = `
[
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(10,0)",
  "context.lineTo(10,10)",
  "context.lineTo(0,10)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.lineWidth = 4",
  "context.stroke()",
  "context.lineWidth = 2",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.strokeText(\\"text\\",10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that sets a nonzero line dash and fills a rect > and then sets a pattern as fill style and fills another rect > and then sets the fill style to something other than a pattern and fills a third rect > and then clears the rect that was filled with a pattern > should set the line dash one fewer time 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(18,2)",
  "context.lineTo(20,2)",
  "context.lineTo(20,4)",
  "context.lineTo(18,4)",
  "context.lineTo(18,2)",
  "context.closePath()",
  "context.moveTo(18,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that sets a nonzero line dash and fills a rect > and then sets a pattern as fill style and fills another rect > and then sets the fill style to something other than a pattern and fills a third rect > should set the correct line dash again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.fill()",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.setLineDash([1,1])",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,2)",
  "context.lineTo(12,2)",
  "context.lineTo(12,4)",
  "context.lineTo(10,4)",
  "context.lineTo(10,2)",
  "context.closePath()",
  "context.moveTo(10,2)",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.fill()",
  "context.restore()",
  "context.fillStyle = \\"#000\\"",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(18,2)",
  "context.lineTo(20,2)",
  "context.lineTo(20,4)",
  "context.lineTo(18,4)",
  "context.lineTo(18,2)",
  "context.closePath()",
  "context.moveTo(18,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that sets a nonzero line dash and fills a rect > and then sets a pattern as fill style and fills another rect > should set the correct line dash again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.fill()",
  "context.fillStyle = \\"[pattern-0]\\"",
  "context.setLineDash([1,1])",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(10,2)",
  "context.lineTo(12,2)",
  "context.lineTo(12,4)",
  "context.lineTo(10,4)",
  "context.lineTo(10,2)",
  "context.closePath()",
  "context.moveTo(10,2)",
  "context.save()",
  "context.transform(2,0,0,2,0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that sets a nonzero line dash and fills a rect > should set the correct line dash 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 2",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(4,2)",
  "context.lineTo(4,4)",
  "context.lineTo(2,4)",
  "context.lineTo(2,2)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that strokes a path using a line dash > should draw a path whose length is a multiple of the line dash period 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([3,2])",
  "context.beginPath()",
  "context.moveTo(100,-50)",
  "context.lineTo(100,-50)",
  "context.lineTo(50,-1.41421356)",
  "context.lineTo(50,-1.55528844)",
  "context.lineTo(50,-1.41421356)",
  "context.lineTo(50,-3.20710678)",
  "context.lineTo(50,-1.41421356)",
  "context.lineTo(50,100)",
  "context.setLineDash([3,2])",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that strokes a rect that extends to infinity > and then changes the line width and strokes another rect that extends to infinity > should have taken a different line width into account for the second rectangle 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(201.41421356,50)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.stroke()",
  "context.lineWidth = 4",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(205.65685425,50)",
  "context.lineTo(205.65685425,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that strokes a rect that extends to infinity > should have taken the current line width into account 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(50,50)",
  "context.lineTo(201.41421356,50)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(50,100)",
  "context.lineTo(50,50)",
  "context.closePath()",
  "context.moveTo(50,50)",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that strokes a rect without area > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that strokes the entire plane > should do nothing 1`] = `[]`;

exports[`an infinite canvas context > that takes text > and fills it > and clears it > should forget the instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that takes text > and fills it > should contain the instruction to transform and fill text 1`] = `
[
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.fillText(\\"Some text\\",100,100)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that takes text > and strokes it > and clears it > should forget the instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that takes text > and strokes it > should contain the instruction to transform and stroke text 1`] = `
[
  "context.save()",
  "context.restore()",
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.strokeText(\\"Some text\\",100,100)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that transforms, begins a path, draws line from a point to infinity, rotates, draws a line to infinity and strokes > should 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,1,0,1,50,50)",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(76.36145268,76.36145268)",
  "context.setTransform(0.92387953,1.30656296,-0.38268343,0.5411961,50,50)",
  "context.lineTo(119.64203051,119.64203051)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that translates > and then draws a line to inifinity > should draw a line to the right border of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,0,0,1,30,60)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(171.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that translates > and then rotates > and then draws a line to inifinity > should draw a line to the right border of the viewbox 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(0,1,-1,0,30,60)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(141.41421356,30)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that translates and draws this shape using a line dash > should make sure the length of the drawn path is a multiple of the line dash period 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setLineDash([2,2])",
  "context.setTransform(1,0,0,1,20,20)",
  "context.beginPath()",
  "context.moveTo(250,50)",
  "context.lineTo(250,50)",
  "context.lineTo(181.41421356,100)",
  "context.lineTo(182.97599346,100)",
  "context.lineTo(181.41421356,100)",
  "context.lineTo(182.70710678,100)",
  "context.lineTo(181.41421356,100)",
  "context.lineTo(100,100)",
  "context.setLineDash([2,2])",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that translates, begins a path, moves to infinity, and then lines to a point > and then lines to a different point > and then strokes > should move to and line to the correct points 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,0,0,1,0,100)",
  "context.beginPath()",
  "context.moveTo(201.41421356,200)",
  "context.lineTo(201.41421356,100)",
  "context.lineTo(100,100)",
  "context.lineTo(100,200)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that translates, begins a path, moves to infinity, and then lines to a point > and then strokes > should move to and line to the correct points 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.setTransform(1,0,0,1,0,100)",
  "context.beginPath()",
  "context.moveTo(201.41421356,100)",
  "context.lineTo(100,100)",
  "context.lineWidth = 1",
  "context.stroke()",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using five arguments > and then clears the rectangle where the image was drawn > should no longer draw the image 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using five arguments > should call the context using five arguments 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10,40,40)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using nine arguments > and then clears the rectangle where the image was drawn > should no longer draw the image 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using nine arguments > should call the context using nine arguments 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10,80,80,10,10,40,40)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using three arguments > and then clears the rectangle where the image was drawn > should no longer draw the image 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that uses an image > and draws it using three arguments > should call the context using three arguments 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.drawImage({\\"width\\":100,\\"height\\":100},10,10)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that uses shadow styles > and then transforms > should transform the shadow offsets together 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 0.5",
  "context.shadowOffsetX = -5",
  "context.shadowOffsetY = 5",
  "context.shadowColor = \\"#000\\"",
  "context.beginPath()",
  "context.moveTo(-5,25)",
  "context.lineTo(-5,75)",
  "context.lineTo(-55,75)",
  "context.lineTo(-55,25)",
  "context.lineTo(-5,25)",
  "context.closePath()",
  "context.moveTo(-5,25)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that uses shadow styles > should use shadow styles 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.shadowOffsetX = 10",
  "context.shadowOffsetY = 10",
  "context.shadowColor = \\"#000\\"",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(130,30)",
  "context.lineTo(130,130)",
  "context.lineTo(30,130)",
  "context.lineTo(30,30)",
  "context.closePath()",
  "context.moveTo(30,30)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > and that uses canvas units > and then draws a square > and then rotates > and then resizes the canvas to exacerbate the distortion > and then draws again > and then rotates again > should have applied an initial transformation that makes the drawing appear with the same distortion, but rotated 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.setTransform(0.5,0,0,2,-4,-34)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.closePath()",
  "context.moveTo(20,20)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(15,15)",
  "context.lineTo(5,15)",
  "context.lineTo(5,5)",
  "context.lineTo(15,5)",
  "context.lineTo(15,15)",
  "context.closePath()",
  "context.moveTo(15,15)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > and that uses canvas units > and then draws a square > and then rotates > and then resizes the canvas to exacerbate the distortion > and then draws again > should have applied an initial transformation that makes the drawing appear more distorted 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.setTransform(2,0,0,0.5,0,-4)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,20)",
  "context.lineTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.closePath()",
  "context.moveTo(0,20)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(5,15)",
  "context.lineTo(5,5)",
  "context.lineTo(15,5)",
  "context.lineTo(15,15)",
  "context.lineTo(5,15)",
  "context.closePath()",
  "context.moveTo(5,15)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > and that uses canvas units > and then draws a square > and then rotates > should have applied an initial transformation that makes the square appear with the same distortion, only rotated 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.setTransform(2,0,0,0.5,0,-4)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,20)",
  "context.lineTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.closePath()",
  "context.moveTo(0,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > and that uses canvas units > and then draws a square > should not have applied an initial transformation 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > that uses CSS units > and then draws a square > and then rotates > should have applied the same initial transformation 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.setTransform(0.6,0,0,0.3,0,0)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,20)",
  "context.lineTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.closePath()",
  "context.moveTo(0,20)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose canvas has a non-identity screen transformation > that uses CSS units > and then draws a square > should have applied an initial transformation that is the inverse of the screen transformation 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,300,300)",
  "context.setTransform(0.6,0,0,0.3,0,0)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed > and then draws something > should have modified the context correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.lineTo(0,0)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then changes the state and clears part of the drawing and draws something else > should have drawn using the state from before the clearing 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(2,0,4,4)",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(3,1)",
  "context.lineTo(4,1)",
  "context.lineTo(4,2)",
  "context.lineTo(3,2)",
  "context.lineTo(3,1)",
  "context.closePath()",
  "context.moveTo(3,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then clears an area containing that instruction > and which then draws something else > should have cleared a rect only once more and should not have executed the old instruction again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#00f\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then clears an area containing that instruction > and which then draws something else without changing the state > should have cleared a rect only once more and should still use the old state 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then clears an area containing that instruction > should have cleared a rectangle 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then draws something else > and which then clears the first part > should have remembered the state for the second part 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.closePath()",
  "context.moveTo(4,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then draws something else > and which then clears the first part and part of the second > should have remembered the state for the second part 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.closePath()",
  "context.moveTo(4,1)",
  "context.fill()",
  "context.save()",
  "context.transform(1,0,0,1,0,0)",
  "context.clearRect(0,0,4.5,4)",
  "context.restore()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and which then draws something else > should not have altered the state 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(4,1)",
  "context.lineTo(6,1)",
  "context.lineTo(6,3)",
  "context.lineTo(4,3)",
  "context.lineTo(4,1)",
  "context.closePath()",
  "context.moveTo(4,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and who changes state, draws something, changes state back and draws something again > and who then clears a rect containing the second drawing > should only have set the remaining state 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(9,1)",
  "context.lineTo(11,1)",
  "context.lineTo(11,3)",
  "context.lineTo(9,3)",
  "context.lineTo(9,1)",
  "context.closePath()",
  "context.moveTo(9,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > and who changes state, draws something, changes state back and draws something again > should have set a new state three times 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
  "context.fillStyle = \\"#00f\\"",
  "context.beginPath()",
  "context.moveTo(5,1)",
  "context.lineTo(7,1)",
  "context.lineTo(7,3)",
  "context.lineTo(5,3)",
  "context.lineTo(5,1)",
  "context.closePath()",
  "context.moveTo(5,1)",
  "context.fill()",
  "context.fillStyle = \\"#f00\\"",
  "context.beginPath()",
  "context.moveTo(9,1)",
  "context.lineTo(11,1)",
  "context.lineTo(11,3)",
  "context.lineTo(9,3)",
  "context.lineTo(9,1)",
  "context.closePath()",
  "context.moveTo(9,1)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > whose state is changed and who draws something > should have modified the context correctly 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = \\"#f00\\"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(3,1)",
  "context.lineTo(3,3)",
  "context.lineTo(1,3)",
  "context.lineTo(1,1)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.fill()",
]
`;
