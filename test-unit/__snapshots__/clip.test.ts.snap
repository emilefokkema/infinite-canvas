// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > and then reduces the path's area, clips again and fills a rect > and then reduces the path's area again and fills it > should have recreated the path and filled it 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = "#f00"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.fill()",
  "context.fillStyle = "#f00"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = "#00f"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.fillStyle = "#f00"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = "#00f"",
  "context.lineTo(50,90)",
  "context.fillStyle = "#ff0"",
  "context.fill()",
]
`;

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > and then reduces the path's area, clips again and fills a rect > should have added a filled rectangle after the clip 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = "#f00"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.fill()",
  "context.fillStyle = "#f00"",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.lineTo(70,30)",
  "context.clip()",
  "context.fillStyle = "#00f"",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > fills a rect, begins a path, clips it and then fills it > should have added an instruction to clip 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.fillStyle = "#f00"",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(100,0)",
  "context.lineTo(100,100)",
  "context.lineTo(0,100)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(10,90)",
  "context.lineTo(90,90)",
  "context.lineTo(90,10)",
  "context.clip()",
  "context.fillStyle = "#0f0"",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > and then fills a rect inside the clipped area > and then clears the entire area > should have cleared everything 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > and then fills a rect inside the clipped area > should have added a fillRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(30,30)",
  "context.lineTo(50,30)",
  "context.lineTo(50,50)",
  "context.lineTo(30,50)",
  "context.closePath()",
  "context.moveTo(30,30)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(35,35)",
  "context.lineTo(45,35)",
  "context.lineTo(45,45)",
  "context.lineTo(35,45)",
  "context.closePath()",
  "context.moveTo(35,35)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips and then fills a rect outside the clipped area > should not have added a fillRect 1`] = `[]`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > and then removes the second filled rectangle by clearing a rect > and then removes the first filled rectangle by clearing a rect > should still contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > and then removes the second filled rectangle by clearing a rect > should still contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.closePath()",
  "context.moveTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that clips with a rect, fills a rect, clips with another rect and then fills two rects > should contain two clipping instructions 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(1,1)",
  "context.lineTo(9,1)",
  "context.lineTo(9,9)",
  "context.lineTo(1,9)",
  "context.closePath()",
  "context.moveTo(1,1)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,5)",
  "context.lineTo(2,5)",
  "context.lineTo(2,7)",
  "context.lineTo(0,7)",
  "context.closePath()",
  "context.moveTo(0,5)",
  "context.fill()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(8,2)",
  "context.lineTo(8,8)",
  "context.lineTo(2,8)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,5)",
  "context.lineTo(9,5)",
  "context.lineTo(9,7)",
  "context.lineTo(7,7)",
  "context.closePath()",
  "context.moveTo(7,5)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(5,5)",
  "context.lineTo(6,5)",
  "context.lineTo(6,7)",
  "context.lineTo(5,7)",
  "context.closePath()",
  "context.moveTo(5,5)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that makes a path, saves state, clips, fills a rect and then strokes the path > should set the clipped path before stroking 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(20,0)",
  "context.lineTo(20,20)",
  "context.lineTo(0,20)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(10,10)",
  "context.lineTo(60,10)",
  "context.lineTo(60,60)",
  "context.lineTo(10,60)",
  "context.closePath()",
  "context.moveTo(10,10)",
  "context.save()",
  "context.clip()",
  "context.lineWidth = 1",
  "context.stroke()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > and then makes a new rectangular path partly overlapping the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > and then once more fills a rect partly overlapping the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > and then clears a rect containing the first overlap > should still contain one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.closePath()",
  "context.moveTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > and then clears a rect containing the second overlap > should still contain one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then fills another rect partly overlapping the clipped area > should still contain only one clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.beginPath()",
  "context.moveTo(0,4)",
  "context.lineTo(6,4)",
  "context.lineTo(6,6)",
  "context.lineTo(0,6)",
  "context.closePath()",
  "context.moveTo(0,4)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and begins a path outside the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and begins a path outside the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and fills a rect outside the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > and then restores state and fills a rect outside the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then fills a rect partly overlapping the clipped area > should contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > and then fills a rect partly overlapping the clipped area > should contain the clipping instruction again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.closePath()",
  "context.moveTo(0,0)",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > and then once again fills the path > should contain the clipping instruction again 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and begins a path outside the clipped area and fills it > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and begins a path outside the clipped area and fills it > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.lineWidth = 1",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and fills a rect outside the clipped area > and then clears a rect that contains that partial overlap > should forget about the filled rect inside the clipped area, not contain a clipping instruction and not add a clearRect 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > and then restores state and fills a rect outside the clipped area > should still contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
  "context.lineWidth = 1",
  "context.beginPath()",
  "context.moveTo(7,0)",
  "context.lineTo(8,0)",
  "context.lineTo(8,1)",
  "context.lineTo(7,1)",
  "context.closePath()",
  "context.moveTo(7,0)",
  "context.fill()",
]
`;

exports[`an infinite canvas context > that saves state, makes a rect and clips it > and then makes a new rectangular path partly overlapping the clipped area and fills it > should contain the clipping instruction 1`] = `
[
  "context.restore()",
  "context.save()",
  "context.clearRect(0,0,200,200)",
  "context.save()",
  "context.beginPath()",
  "context.moveTo(2,2)",
  "context.lineTo(5,2)",
  "context.lineTo(5,5)",
  "context.lineTo(2,5)",
  "context.closePath()",
  "context.moveTo(2,2)",
  "context.clip()",
  "context.beginPath()",
  "context.moveTo(0,0)",
  "context.lineTo(6,0)",
  "context.lineTo(6,3)",
  "context.lineTo(0,3)",
  "context.lineTo(0,0)",
  "context.lineWidth = 1",
  "context.fill()",
  "context.restore()",
]
`;
